# V1.2 Feature 4.1: Cost Tracking Design

**Goal**: Track and report API costs for transparency and budget monitoring

---

## Current State

**No Cost Tracking**:
- API calls are made to Gemini Flash
- No token usage recorded
- No cost calculations
- No visibility into spending

**Problems**:
- Can't monitor API spending
- Can't forecast costs for large runs
- Can't identify expensive tweets
- No cost accountability for multi-project usage

---

## Gemini API Token Usage

### Response Metadata

Gemini API responses include `usage_metadata`:
```python
response = model.generate_content(prompt, ...)

# Access token counts
usage = response.usage_metadata
input_tokens = usage.prompt_token_count
output_tokens = usage.candidates_token_count
total_tokens = usage.total_token_count
```

### Gemini Flash Pricing (2024)

| Token Type | Cost per 1M Tokens |
|------------|-------------------|
| Input (prompt) | $0.075 |
| Output (completion) | $0.30 |

**Example Calculation**:
- Input: 500 tokens Ã— $0.075 / 1M = $0.0000375
- Output: 150 tokens Ã— $0.30 / 1M = $0.000045
- **Total**: $0.0000825 per generation (~$0.00008)

**Typical V1 Generation**:
- Prompt: ~400-600 tokens (tweet + instructions + examples)
- Output: ~100-200 tokens (3 suggestions as JSON)
- **Cost per tweet**: ~$0.00006 - $0.00010

**V1.2 Batch Generation (426 tweets)**:
- 426 tweets Ã— $0.00008 = **$0.034 per run**
- Very affordable for most use cases

---

## Design

### 1. Database Schema

**Add column to `generated_comments` table**:
```sql
ALTER TABLE public.generated_comments
ADD COLUMN api_cost_usd numeric(10, 8) DEFAULT 0.0;

COMMENT ON COLUMN public.generated_comments.api_cost_usd IS 'Gemini API cost in USD for this suggestion (input + output tokens)';
```

**Why `numeric(10, 8)`?**
- Stores up to $99.99999999 with 8 decimal precision
- Typical value: $0.00008 (8 decimal places needed)
- Allows for future price increases

**Index for Cost Queries**:
```sql
CREATE INDEX IF NOT EXISTS idx_generated_comments_cost
  ON public.generated_comments(project_id, created_at DESC, api_cost_usd);
```

### 2. Cost Calculation Module

**New file: `viraltracker/generation/cost_tracking.py`**

```python
from dataclasses import dataclass
from typing import Optional

@dataclass
class TokenUsage:
    """Token usage from Gemini API response"""
    prompt_tokens: int
    completion_tokens: int
    total_tokens: int

@dataclass
class APICost:
    """API cost calculation"""
    input_tokens: int
    output_tokens: int
    input_cost_usd: float
    output_cost_usd: float
    total_cost_usd: float

# Gemini Flash pricing (per 1M tokens)
GEMINI_FLASH_INPUT_COST_PER_1M = 0.075
GEMINI_FLASH_OUTPUT_COST_PER_1M = 0.30

def calculate_cost(token_usage: TokenUsage) -> APICost:
    """
    Calculate API cost from token usage.

    Args:
        token_usage: Token counts from Gemini API

    Returns:
        APICost with breakdown
    """
    input_cost = (token_usage.prompt_tokens / 1_000_000) * GEMINI_FLASH_INPUT_COST_PER_1M
    output_cost = (token_usage.completion_tokens / 1_000_000) * GEMINI_FLASH_OUTPUT_COST_PER_1M

    return APICost(
        input_tokens=token_usage.prompt_tokens,
        output_tokens=token_usage.completion_tokens,
        input_cost_usd=input_cost,
        output_cost_usd=output_cost,
        total_cost_usd=input_cost + output_cost
    )

def extract_token_usage(response) -> Optional[TokenUsage]:
    """
    Extract token usage from Gemini API response.

    Args:
        response: Gemini API response object

    Returns:
        TokenUsage or None if not available
    """
    try:
        usage = response.usage_metadata
        return TokenUsage(
            prompt_tokens=usage.prompt_token_count,
            completion_tokens=usage.candidates_token_count,
            total_tokens=usage.total_token_count
        )
    except (AttributeError, KeyError) as e:
        logger.warning(f"Failed to extract token usage: {e}")
        return None
```

### 3. Integration Points

#### A. CommentGenerator.generate_suggestions()

**After API call** (line 191 in comment_generator.py):
```python
# Make API call
response = model.generate_content(...)

# Record successful call
self.rate_limiter.record_call()

# V1.2: Extract token usage for cost tracking
token_usage = extract_token_usage(response)
api_cost = calculate_cost(token_usage) if token_usage else None
```

**Store in GenerationResult**:
```python
@dataclass
class GenerationResult:
    tweet_id: str
    suggestions: List[CommentSuggestion]
    success: bool
    error: Optional[str] = None
    safety_blocked: bool = False
    api_cost_usd: Optional[float] = None  # V1.2: Cost tracking
```

#### B. save_suggestions_to_db()

**Update record structure** (line 414 in comment_generator.py):
```python
record = {
    'project_id': project_id,
    'tweet_id': tweet_id,
    'suggestion_type': suggestion.suggestion_type,
    'comment_text': suggestion.comment_text,
    'score_total': scoring_result.total_score,
    'label': scoring_result.label,
    'topic': scoring_result.best_topic,
    'why': why,
    'rank': suggestion.rank,
    'review_status': 'pending',
    'status': 'pending',
    'api_cost_usd': api_cost_usd  # V1.2: Store cost
}
```

**Cost per suggestion**:
- Each tweet generates 3 suggestions (add_value, ask_question, mirror_reframe)
- All 3 come from 1 API call
- **Divide total cost by 3** to get cost per suggestion

#### C. CLI Reporting

**After generation completes** (in twitter.py):
```python
# Print summary
click.echo(f"\nâœ… Generated {success_count} comment opportunities")
if error_count > 0:
    click.echo(f"âš ï¸  {error_count} tweets failed")

# V1.2: Show total cost
if total_cost > 0:
    click.echo(f"ðŸ’° API Cost: ${total_cost:.4f} USD")
```

### 4. Cost Reporting Queries

**Total cost by project**:
```sql
SELECT
    project_id,
    COUNT(DISTINCT tweet_id) as tweets_processed,
    COUNT(*) as suggestions_generated,
    SUM(api_cost_usd) as total_cost_usd,
    AVG(api_cost_usd) as avg_cost_per_suggestion
FROM generated_comments
WHERE created_at >= NOW() - INTERVAL '7 days'
GROUP BY project_id
ORDER BY total_cost_usd DESC;
```

**Cost by date**:
```sql
SELECT
    DATE(created_at) as date,
    COUNT(DISTINCT tweet_id) as tweets,
    SUM(api_cost_usd) as cost_usd
FROM generated_comments
WHERE project_id = 'xxx'
GROUP BY DATE(created_at)
ORDER BY date DESC;
```

---

## Implementation Plan

### Phase 1: Cost Calculation Module (30 min)
1. Create `viraltracker/generation/cost_tracking.py`
2. Implement `TokenUsage`, `APICost` dataclasses
3. Implement `calculate_cost()` function
4. Implement `extract_token_usage()` function
5. Add unit tests

### Phase 2: Database Migration (15 min)
1. Create migration file `2025-10-22_add_api_cost.sql`
2. Add `api_cost_usd` column to `generated_comments`
3. Add index for cost queries
4. Run migration

### Phase 3: Integration (45 min)
1. Update `GenerationResult` dataclass
2. Extract token usage in `generate_suggestions()`
3. Calculate cost and store in result
4. Update `save_suggestions_to_db()` to store cost
5. Update CLI to report total cost

### Phase 4: Testing (30 min)
1. Test with real API calls (yakety-pack-instagram)
2. Verify token counts extracted correctly
3. Verify costs calculated correctly
4. Verify costs saved to database
5. Verify CLI reporting

**Total Time**: 2 hours

---

## Success Metrics

1. **Token Extraction**: 100% of successful API calls have token counts
2. **Cost Accuracy**: Costs match manual calculations (Â±$0.00000001)
3. **Database Storage**: All suggestions have api_cost_usd populated
4. **CLI Reporting**: Total cost displayed after generation runs
5. **No Performance Impact**: Cost tracking adds <1ms overhead

---

## Example Output

### Before (V1.1)
```bash
âœ… Generated 12 comment opportunities
â±ï¸  Total time: 11.347s
```

### After (V1.2)
```bash
âœ… Generated 12 comment opportunities
ðŸ’° API Cost: $0.0010 USD (avg $0.00008 per tweet)
â±ï¸  Total time: 11.347s
```

### Large Run Example (426 tweets)
```bash
âœ… Generated 426 comment opportunities
ðŸ’° API Cost: $0.0341 USD (avg $0.00008 per tweet)
â±ï¸  Total time: 341s (5.7 min)
```

---

## Future Enhancements (V1.3+)

1. **Budget Alerts**: Warn if cost exceeds threshold
2. **Cost Forecasting**: Estimate cost before running
3. **Cost by Topic**: Track which topics are most expensive
4. **Cost Optimization**: Identify and reduce prompt bloat
5. **Cost Reports**: Weekly/monthly summaries via email

---

## Edge Cases

### 1. Token Usage Not Available
**Scenario**: API response doesn't include usage_metadata
**Handling**: Set api_cost_usd to 0.0, log warning

### 2. Batch Processing
**Scenario**: Multiple tweets processed concurrently
**Handling**: Each tweet's cost calculated independently, sum for total

### 3. Failed API Calls
**Scenario**: API call fails (rate limit, safety block, etc.)
**Handling**: No cost recorded (no successful response = no cost)

### 4. Retries
**Scenario**: Rate limit hit, retry with exponential backoff
**Handling**: Only record cost for successful call, not retries

---

## Pricing Updates

**How to update pricing**:
1. Edit `GEMINI_FLASH_INPUT_COST_PER_1M` in `cost_tracking.py`
2. Edit `GEMINI_FLASH_OUTPUT_COST_PER_1M` in `cost_tracking.py`
3. Costs for future generations will use new pricing
4. Historical costs remain unchanged (point-in-time accuracy)

**Where to check current pricing**:
- https://ai.google.dev/pricing
- Gemini Flash 2.0 pricing page

---

**Status**: Design Complete - Ready for Implementation
**Estimated Time**: 2 hours
**Priority**: MEDIUM (nice-to-have for transparency, not critical)
